import java.nio.file.*
import java.util.zip.*

import groovy.json.JsonSlurper

plugins {
    id "java"
}

group 'net.buj'
version '1.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(8)
    }
}

if (Files.exists(Paths.get(project.rootDir.toString(), "client/src/main"))) {
    defaultTasks 'createPatches', 'pack'
}
else {
    defaultTasks 'prepare', 'processPatches', 'pack'
}

if (JavaVersion.current() != JavaVersion.VERSION_1_8) {
    System.err.println("/!\\ Warning! /!\\")
    System.err.println("Rosepad ONLY supports Java 8")
    System.err.println("")
    System.err.println("Compiling Rosepad with anything other than JDK 8 might result in " +
            "broken jar file. Use -Dorg.gradle.java.home=/path/to/your/java8/home to change your JDK version " +
            "for this build")
    System.err.println("")
    System.err.println("Build will resume in 10 seconds")
    Thread.sleep(10000)
}

tasks.register("setupJDK") {
    doLast {
        Utils.java17path = System.getenv("TOOLKIT_JAVA17")

        if (Utils.java17path == null) {
            def jdkpath = Paths.get(project.rootDir.toString(), "tools/jdk17")
            Utils.java17path = jdkpath.toAbsolutePath()
            if (!Files.exists(Paths.get(Utils.java17path))) {
                println "Downloading JDK17..."

                String url = Utils.getDownloadURL(
                    System.properties['os.arch'].replace("amd64", "x64"),
                    System.properties['os.name'].toLowerCase().split(" ")[0]
                )

                if (url == null) throw new RuntimeException("Running Rosepad toolchain requires JDK 17. " +
                    "Set TOOLKIT_JAVA17 environment variable " +
                    "to your JDK 17 installation")
                Utils.fetch(url, Paths.get(project.rootDir.toString(), "tools/jdk17.tar.gz"))

                println "Unpacking JDK17..."

                try {
                    copy {
                        from(tarTree(Paths.get(project.rootDir.toString(), "tools/jdk17.tar.gz")))
                        into(Utils.java17path)
                    }
                } catch (Exception ignored) {
                    println "Error while unpacking JDK, ignoring"
                }

                Files.list(Files.list(Paths.get(project.rootDir.toString(), "tools/jdk17")).findAny().get()).forEach(e -> {
                    Files.move(e, Paths.get(Utils.java17path).resolve(e.fileName));
                })
            }
        }
    }
}

class Utils {
    static String java17path = null;

    private Utils() {}

    static String getDownloadURL(String arch, String os) { // No autocomplete :sad_face:
        def json$1 = new URL("https://api.github.com/repos/adoptium/temurin17-binaries/releases?per_page=1").getText()
        def js     = new JsonSlurper()
        def json   = js.parseText(json$1)[0].assets
        def name   = "OpenJDK17U-jdk_${arch}_${os}_".toString()

        for (def object : json) {
            if (!object.name.startsWith(name)) continue

            return object.browser_download_url
        }

        return null
    }

    static def fetch(String file, Path path) {
        if (new File(path.toString()).isFile()) return
        Path parent = path.parent
        Files.createDirectories(parent)
        Files.copy(new URL(file).openStream(), path, StandardCopyOption.REPLACE_EXISTING)
    }

    static def enigma(Path jar, Path source, Path dest, Path tiny2map) {
        new File(dest.toString()).mkdirs() // JIC directory does not exists
        Path jre = Paths.get(Utils.java17path.toString(), "bin", "java")

        List<String> command = new ArrayList<String>()
        command.add(jre.toAbsolutePath().normalize().toString())
        command.add("-jar")
        command.add(jar.toAbsolutePath().normalize().toString())
        command.add("decompile")
        command.add("procyon")
        command.add(source.toAbsolutePath().normalize().toString())
        command.add(dest.toAbsolutePath().normalize().toString())
        command.add(tiny2map.toAbsolutePath().normalize().toString())

        Process process = new ProcessBuilder(command).start()
        StreamGobbler out = new StreamGobbler(process.inputStream)
        StreamGobbler err = new StreamGobbler(process.errorStream)
        out.start()
        err.start()

        if (process.waitFor() != 0) {
            throw new RuntimeException("Failed to decompile source")
        }
    }

    static boolean isDamaged(File file) {
        if (file.isDirectory()) {
            for (File sub : file.listFiles()) {
                if (isDamaged(sub)) {
                    return true
                }
            }
            return false
        }

        FileInputStream stream = new FileInputStream(file);
        Scanner scanner = new Scanner(stream);

        while (scanner.hasNextLine()) {
            String line = scanner.nextLine();
            if (line.contains("java.lang.ArrayIndexOutOfBoundsException") ||
                line.contains("An error occurred while decompiling this method") ||
                line.contains("com.strobel.assembler.metadata.MethodBodyParseException")) {
                stream.close()
                scanner.close()
                return true
            }
        }

        stream.close()
        scanner.close()

        return false
    }

    static def merge(File fix, File dest) {
        if (fix.isDirectory()) {
            for (String sub : fix.list()) {
                merge(new File(fix, sub), new File(dest, sub));
            }
        }
        else if (isDamaged(dest)) {
            cp(fix.toPath(), dest.toPath())
        }
    }

    static def decompile(Path jar, Path source, Path dest, Path tiny2map) {
        Path fix = dest

        do {
            if (fix != dest) {
                println "Detected damaged files, re-running Enigma..."
            }
            enigma(jar, source, fix, tiny2map)
            if (fix == dest) {
                fix = dest.parent.resolve(".java-tmp")
            }
            else {
                merge(fix.toFile(), dest.toFile())
                rm(fix)
            }
        } while (isDamaged(dest.toFile()));
    }

    static def tiny(Path jar, Path source, Path dest, Path tiny2map, String from, String to) {
        new File(dest.parent.toString()).mkdirs() // JIC directory does not exists
        Path jre = Paths.get(Utils.java17path.toString(), "bin", "java")

        List<String> command = new ArrayList<String>()
        command.add(jre.toAbsolutePath().normalize().toString())
        command.add("-jar")
        command.add(jar.toAbsolutePath().normalize().toString())
        command.add(source.toAbsolutePath().normalize().toString())
        command.add(dest.toAbsolutePath().normalize().toString())
        command.add(tiny2map.toAbsolutePath().normalize().toString())
        command.add(from)
        command.add(to)

        Process process = new ProcessBuilder(command).start()
        StreamGobbler out = new StreamGobbler(process.inputStream)
        StreamGobbler err = new StreamGobbler(process.errorStream)
        out.start()
        err.start()

        if (process.waitFor() != 0) {
            throw new RuntimeException("Failed to apply mappings")
        }
    }

    static def rm(Path path) {
        File file = new File(path.toString())
        if (file.isDirectory()) {
            for (File sf : file.listFiles()) {
                rm(sf.toPath())
            }
        }
        file.delete()
    }

    static def cp(Path source, Path dest) {
        File file = source.toFile()
        if (file.isDirectory()) {
            dest.toFile().mkdirs()
            for (String sf : file.list()) {
                cp(source.resolve(sf), dest.resolve(sf))
            }
        }
        else if (file.isFile()) {
            Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING)
        }
    }
}

class StreamGobbler extends Thread { // Stolen from a guy on stackoverflow
    InputStream is

    StreamGobbler(InputStream is) {
        this.is = is
    }

    void run() {
        try {
            InputStreamReader isr = new InputStreamReader(is)
            BufferedReader br = new BufferedReader(isr)
            String line = null
            while ((line = br.readLine()) != null)
                System.out.println(line)
        } catch (IOException ioe) {
            ioe.printStackTrace()
        }
    }
}

tasks.register("prepare") {
    dependsOn "setupJDK"

    doLast {
        Utils.fetch(
            "https://github.com/AlphaVerUnofficialJars/LilypadClient/releases/download/v106/lilypad_qamod_v106.jar",
            Paths.get(project.rootDir.toString(), "jars", "lilypad_client_s.jar"),
        )
        Utils.fetch(
            "https://github.com/AlphaVerUnofficialJars/LilypadServer/releases/download/v105/lilypad_server_v105.jar",
            Paths.get(project.rootDir.toString(), "jars", "lilypad_server_s.jar"),
        )

        copy {
            from(zipTree(Paths.get(project.rootDir.toString(), "jars", "lilypad_client_s.jar")))
            into(Paths.get(project.rootDir.toString(), "client/src/main/resources"))
            exclude "**/*.class", "com/**", "net/**", "org/**", "paulscode/**"
        }

        Utils.decompile(
            Paths.get(project.rootDir.toString(), "tools", "enigma.jar"),
            Paths.get(project.rootDir.toString(), "jars", "lilypad_client_s.jar"),
            Paths.get(project.rootDir.toString(), "client/src/main/java"),
            Paths.get(project.rootDir.toString(), "mappings", "client.tiny2"),
        )
        Utils.decompile(
            Paths.get(project.rootDir.toString(), "tools", "enigma.jar"),
            Paths.get(project.rootDir.toString(), "jars", "lilypad_server_s.jar"),
            Paths.get(project.rootDir.toString(), "server/src/main/java"),
            Paths.get(project.rootDir.toString(), "mappings", "server_deobf.tiny"),
        )

        Utils.rm(Paths.get(project.rootDir.toString(), "client/src/main/java/paulscode"))
        Utils.rm(Paths.get(project.rootDir.toString(), "client/src/main/java/com"))
        Utils.rm(Paths.get(project.rootDir.toString(), "client/src/main/java/org"))
        Utils.rm(Paths.get(project.rootDir.toString(), "client/src/main/java/net/java"))

        Utils.rm(Paths.get(project.rootDir.toString(), "client/src/orig"))

        copy {
            from Paths.get(project.rootDir.toString(), "client/src/main/java")
            into Paths.get(project.rootDir.toString(), "client/src/orig/java")
        }

        Path serverDefaultPkg = Paths.get(project.rootDir.toString(), "server/src/main/java")
        for (String file : serverDefaultPkg.toFile().list()) {
            if (!new File(serverDefaultPkg.toFile(), file).isFile()) continue
            FileReader reader = new FileReader(new File(serverDefaultPkg.toFile(), file))
            FileWriter writer = new FileWriter(new File(serverDefaultPkg.toFile(), "net/minecraft/src/" + file))
            Scanner scanner = new Scanner(reader)
            writer.write("package net.minecraft.src;\n\n")
            while (scanner.hasNextLine()) {
                writer.write(scanner.nextLine())
                writer.write("\n")
            }
            scanner.close()
            reader.close()
            writer.close()
            Files.deleteIfExists(Paths.get(serverDefaultPkg.toString(), file))
        }

        Utils.rm(Paths.get(project.rootDir.toString(), "server/src/orig"))
        Utils.cp(
            Paths.get(project.rootDir.toString(), "server/src/main/java"),
            Paths.get(project.rootDir.toString(), "server/src/orig/java"),
        )
        copy {
            from(Paths.get(project.rootDir.toString(), "client/src/main/resources"))
            into(Paths.get(project.rootDir.toString(), "client/src/orig/resources"))
        }
    }
}

tasks.register("compileSub") {
    dependsOn "setupJDK"
    dependsOn ":client:shadowJar"
    dependsOn ":server:shadowJar"
}

subprojects {
    java {
        toolchain {
            languageVersion = JavaLanguageVersion.of(8)
        }
    }
}
