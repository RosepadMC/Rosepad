--- Chunk.java
+++ Chunk.java
@@ -13,8 +13,14 @@
     public World worldObj;
     public NibbleArray data;
-    public NibbleArray skylightMap;
-    public NibbleArray blocklightMap;
+    public NibbleArray skylightMapR;
+    public NibbleArray skylightMapG;
+    public NibbleArray skylightMapB;
+    public NibbleArray blocklightMapR;
+    public NibbleArray blocklightMapG;
+    public NibbleArray blocklightMapB;
     public byte[] heightMap;
-    public int height;
+    public int heightR;
+    public int heightG;
+    public int heightB;
     public final int xPosition;
     public final int zPosition;
@@ -27,8 +33,8 @@
     public boolean hasEntities;
     public long lastSaveTime;
-    
+
     public Chunk(final World world, final int xPos, final int zPos) {
-        this.chunkTileEntityMap = (Map<ChunkPosition, TileEntity>)new HashMap();
-        this.entities = (List<List<Entity>>)new ArrayList(8);
+        this.chunkTileEntityMap = new HashMap<>();
+        this.entities = new ArrayList<>(8);
         this.isTerrainPopulated = false;
         this.isModified = false;
@@ -41,27 +47,31 @@
         this.heightMap = new byte[256];
         for (int i = 0; i < 8; ++i) {
-            this.entities.add(new ArrayList());
+            this.entities.add(new ArrayList<>());
         }
     }
-    
+
     public Chunk(final World world, final byte[] blocks, final int xPos, final int zPos) {
         this(world, xPos, zPos);
         this.blocks = blocks;
         this.data = new NibbleArray(blocks.length);
-        this.skylightMap = new NibbleArray(blocks.length);
-        this.blocklightMap = new NibbleArray(blocks.length);
+        this.skylightMapR = new NibbleArray(blocks.length);
+        this.skylightMapG = new NibbleArray(blocks.length);
+        this.skylightMapB = new NibbleArray(blocks.length);
+        this.blocklightMapR = new NibbleArray(blocks.length);
+        this.blocklightMapG = new NibbleArray(blocks.length);
+        this.blocklightMapB = new NibbleArray(blocks.length);
     }
-    
+
     public boolean isAtLocation(final int xPos, final int zPos) {
         return xPos == this.xPosition && zPos == this.zPosition;
     }
-    
+
     public int getHeightValue(final int blockX, final int blockZ) {
         return this.heightMap[blockZ << 4 | blockX] & 0xFF;
     }
-    
+
     public void doNothing() {
     }
-    
+
     public void generateHeightMap() {
         int height = 127;
@@ -69,5 +79,5 @@
             for (int j = 0; j < 16; ++j) {
                 int n = 127;
-                for (int n2 = i << 11 | j << 7; n > 0 && Block.LIGHT_OPACITY[this.blocks[n2 + n - 1]] == 0; --n) {}
+                for (int n2 = i << 11 | j << 7; n > 0 && Block.LIGHT_OPACITY_R[this.blocks[n2 + n - 1]] == 0 && Block.LIGHT_OPACITY_G[this.blocks[n2 + n - 1]] == 0 && Block.LIGHT_OPACITY_B[this.blocks[n2 + n - 1]] == 0; --n) {}
                 this.heightMap[j << 4 | i] = (byte)n;
                 if (n < height) {
@@ -76,8 +86,10 @@
             }
         }
-        this.height = height;
+        this.heightR = height;
+        this.heightG = height;
+        this.heightB = height;
         this.isModified = true;
     }
-    
+
     public void generateSkylightMap() {
         int height = 127;
@@ -91,5 +103,7 @@
             }
         }
-        this.height = height;
+        this.heightR = height;
+        this.heightG = height;
+        this.heightB = height;
         for (int i = 0; i < 16; ++i) {
             for (int j = 0; j < 16; ++j) {
@@ -99,5 +113,5 @@
         this.isModified = true;
     }
-    
+
     private void updateSkylight_do(final int x, final int z) {
         final int heightValue = this.getHeightValue(x, z);
@@ -109,5 +123,5 @@
         this.checkSkylightNeighborUpdate(n, n2 + 1, heightValue);
     }
-    
+
     private void checkSkylightNeighborUpdate(final int blockX, final int blockY, final int blockZ) {
         final int heightValue = this.worldObj.getHeightValue(blockX, blockY);
@@ -120,74 +134,104 @@
         this.isModified = true;
     }
-    
+
     private void relightBlock(final int x, final int y, final int z) {
-        final int n3;
-        int n2 = n3 = (this.heightMap[z << 4 | x] & 0xFF);
-        if (y > n3) {
-            n2 = y;
-        }
-        for (int n4 = x << 11 | z << 7; n2 > 0 && Block.LIGHT_OPACITY[this.blocks[n4 + n2 - 1]] == 0; --n2) {}
-        if (n2 == n3) {
-            return;
-        }
-        this.worldObj.markBlocksDirtyVertical(x, z, n2, n3);
-        this.heightMap[z << 4 | x] = (byte)n2;
-        if (n2 < this.height) {
-            this.height = n2;
-        }
-        else {
-            int n5 = 127;
-            for (int i = 0; i < 16; ++i) {
-                for (int j = 0; j < 16; ++j) {
-                    if ((this.heightMap[j << 4 | i] & 0xFF) < n5) {
-                        n5 = (this.heightMap[j << 4 | i] & 0xFF);
+        for (int colorOrdinal = 0; colorOrdinal < 3; colorOrdinal++) {
+            final int[] opacityArray = colorOrdinal == 0 ? Block.LIGHT_OPACITY_R
+                : colorOrdinal == 1 ? Block.LIGHT_OPACITY_G
+                : Block.LIGHT_OPACITY_B;
+            final NibbleArray skylightMap = colorOrdinal == 0 ? this.skylightMapR
+                : colorOrdinal == 1 ? this.skylightMapG
+                : this.skylightMapB;
+            final int maxY;
+            int minY = maxY = (this.heightMap[z << 4 | x] & 0xFF);
+            if (y > maxY) {
+                minY = y;
+            }
+            for (int column = x << 11 | z << 7; minY > 0 && opacityArray[this.blocks[column + minY - 1]] == 0; --minY) {}
+            if (minY == maxY) {
+                return;
+            }
+            this.worldObj.markBlocksDirtyVertical(x, z, minY, maxY);
+            this.heightMap[z << 4 | x] = (byte)minY;
+            if (minY < (colorOrdinal == 0 ? this.heightR : colorOrdinal == 1 ? this.heightG : this.heightB)) {
+                switch (colorOrdinal) {
+                    case 0:
+                        this.heightR = minY;
+                        break;
+                    case 1:
+                        this.heightG = minY;
+                        break;
+                    default:
+                        this.heightB = minY;
+                        break;
+                }
+            }
+            else {
+                int height = 127;
+                for (int i = 0; i < 16; ++i) {
+                    for (int j = 0; j < 16; ++j) {
+                        if ((this.heightMap[j << 4 | i] & 0xFF) < height) {
+                            height = (this.heightMap[j << 4 | i] & 0xFF);
+                        }
                     }
                 }
+                switch (colorOrdinal) {
+                    case 0:
+                        this.heightR = minY;
+                        break;
+                    case 1:
+                        this.heightG = minY;
+                        break;
+                    default:
+                        this.heightB = minY;
+                        break;
+                }
             }
-            this.height = n5;
-        }
-        int n5 = this.xPosition * 16 + x;
-        int i = this.zPosition * 16 + z;
-        if (n2 < n3) {
-            for (int j = n2; j < n3; ++j) {
-                this.skylightMap.set(x, j, z, 15);
+            int n5 = this.xPosition * 16 + x;
+            int i = this.zPosition * 16 + z;
+            if (minY < maxY) {
+                for (int j = minY; j < maxY; ++j) {
+                    skylightMap.set(x, j, z, 15);
+                }
             }
-        }
-        else {
-            this.worldObj.scheduleLightingUpdate(EnumSkyBlock.SKY, n5, n3, i, n5, n2, i);
-            for (int j = n3; j < n2; ++j) {
-                this.skylightMap.set(x, j, z, 0);
+            else {
+                this.worldObj.scheduleLightingUpdate(EnumSkyBlock.SKY, n5, maxY, i, n5, minY, i);
+                for (int j = maxY; j < minY; ++j) {
+                    skylightMap.set(x, j, z, 0);
+                }
             }
-        }
-        int j = 15;
-        final int maxY = n2;
-        while (n2 > 0) {
-            if (j <= 0) {
-                break;
+            int j = 15;
+            final int otherMaxY = minY;
+            while (minY > 0) {
+                if (j == 0) {
+                    break;
+                }
+                --minY;
+                int n6 = opacityArray[this.getBlockID(x, minY, z)];
+                if (n6 == 0) {
+                    n6 = 1;
+                }
+                j -= n6;
+                if (j < 0) {
+                    j = 0;
+                }
+                this.skylightMapR.set(x, minY, z, j);
+                this.skylightMapG.set(x, minY, z, j);
+                this.skylightMapB.set(x, minY, z, j);
             }
-            --n2;
-            int n6 = Block.LIGHT_OPACITY[this.getBlockID(x, n2, z)];
-            if (n6 == 0) {
-                n6 = 1;
+            while (minY > 0 && opacityArray[this.getBlockID(x, minY - 1, z)] == 0) {
+                --minY;
             }
-            j -= n6;
-            if (j < 0) {
-                j = 0;
+            if (minY != otherMaxY) {
+                this.worldObj.scheduleLightingUpdate(EnumSkyBlock.SKY, n5 - 1, minY, i - 1, n5 + 1, otherMaxY, i + 1);
             }
-            this.skylightMap.set(x, n2, z, j);
+            this.isModified = true;
         }
-        while (n2 > 0 && Block.LIGHT_OPACITY[this.getBlockID(x, n2 - 1, z)] == 0) {
-            --n2;
-        }
-        if (n2 != maxY) {
-            this.worldObj.scheduleLightingUpdate(EnumSkyBlock.SKY, n5 - 1, n2, i - 1, n5 + 1, maxY, i + 1);
-        }
-        this.isModified = true;
     }
-    
+
     public int getBlockID(final int x, final int y, final int z) {
         return this.blocks[x << 11 | z << 7 | y];
     }
-    
+
     public boolean setBlockIDWithMetadata(final int x, final int y, final int z, final int id, final int metadata) {
         final byte b = (byte)id;
@@ -204,5 +248,5 @@
         }
         this.data.set(x, y, z, metadata);
-        if (Block.LIGHT_OPACITY[b] != 0) {
+        if (Block.LIGHT_OPACITY_R[b] != 0 || Block.LIGHT_OPACITY_G[b] != 0 || Block.LIGHT_OPACITY_B[b] != 0) {
             if (y >= n) {
                 this.relightBlock(x, y + 1, z);
@@ -220,5 +264,5 @@
         return this.isModified = true;
     }
-    
+
     public boolean setBlockID(final int x, final int y, final int z, final int id) {
         final byte b = (byte)id;
@@ -235,5 +279,5 @@
         }
         this.data.set(x, y, z, 0);
-        if (Block.LIGHT_OPACITY[b] != 0) {
+        if (Block.LIGHT_OPACITY_R[b] != 0 || Block.LIGHT_OPACITY_G[b] != 0 || Block.LIGHT_OPACITY_B[b] != 0) {
             if (y >= n) {
                 this.relightBlock(x, y + 1, z);
@@ -251,44 +295,72 @@
         return this.isModified = true;
     }
-    
+
     public int getBlockMetadata(final int x, final int y, final int z) {
         return this.data.get(x, y, z);
     }
-    
+
     public void setBlockMetadata(final int x, final int y, final int z, final int metadata) {
         this.isModified = true;
         this.data.set(x, y, z, metadata);
     }
-    
-    public int getSavedLightValue(final EnumSkyBlock skyBlock, final int x, final int y, final int z) {
+
+    public int getAvgSavedLightValue(final EnumSkyBlock skyBlock, final int x, final int y, final int z) {
         if (skyBlock == EnumSkyBlock.SKY) {
-            return this.skylightMap.get(x, y, z);
+            return (this.skylightMapR.get(x, y, z) + this.skylightMapG.get(x, y, z) * 3 + this.skylightMapB.get(x, y, z) * 2) / 6;
         }
         if (skyBlock == EnumSkyBlock.BLOCK) {
-            return this.blocklightMap.get(x, y, z);
+            return (this.blocklightMapR.get(x, y, z) + this.blocklightMapG.get(x, y, z) * 3 + this.blocklightMapB.get(x, y, z) * 2) / 6;
         }
         return 0;
     }
-    
-    public void setLightValue(final EnumSkyBlock skyBlock, final int x, final int y, final int z, final int lightValue) {
+
+    public int getSavedLightValue(final EnumSkyBlock skyBlock, final EnumColorChannel colorChannel, final int x, final int y, final int z) {
+        if (skyBlock == EnumSkyBlock.SKY) {
+            if (colorChannel == EnumColorChannel.RED) return this.skylightMapR.get(x, y, z);
+            if (colorChannel == EnumColorChannel.GREEN) return this.skylightMapG.get(x, y, z);
+            return this.skylightMapB.get(x, y, z);
+        }
+
+        if (colorChannel == EnumColorChannel.RED) return this.blocklightMapR.get(x, y, z);
+        if (colorChannel == EnumColorChannel.GREEN) return this.blocklightMapG.get(x, y, z);
+        return this.blocklightMapB.get(x, y, z);
+    }
+
+    public void setLightValue(final EnumSkyBlock skyBlock, final int x, final int y, final int z, final int lightValue, final EnumColorChannel color) {
         this.isModified = true;
         if (skyBlock == EnumSkyBlock.SKY) {
-            this.skylightMap.set(x, y, z, lightValue);
+            if (color == EnumColorChannel.RED) this.skylightMapR.set(x, y, z, lightValue);
+            else if (color == EnumColorChannel.GREEN) this.skylightMapG.set(x, y, z, lightValue);
+            else this.skylightMapB.set(x, y, z, lightValue);
         }
-        else {
-            if (skyBlock != EnumSkyBlock.BLOCK) {
-                return;
-            }
-            this.blocklightMap.set(x, y, z, lightValue);
+        if (color == EnumColorChannel.RED) this.blocklightMapR.set(x, y, z, lightValue);
+        else if (color == EnumColorChannel.GREEN) this.blocklightMapG.set(x, y, z, lightValue);
+        else this.blocklightMapB.set(x, y, z, lightValue);
+    }
+
+    public int getAvgBlockLightValue(final int x, final int y, final int z, final int skyLightSubtracted) {
+        int value = (this.skylightMapR.get(x, y, z) + this.skylightMapG.get(x, y, z) * 3 + this.skylightMapB.get(x, y, z) * 2) / 6;
+        final int value2 = value;
+        if (value > 0) {
+            Chunk.isLit = true;
         }
+        value -= skyLightSubtracted;
+        if (value2 > value) {
+            value = value2;
+        }
+        return value;
     }
-    
-    public int getBlockLightValue(final int x, final int y, final int z, final int skyLightSubtracted) {
-        int value = this.skylightMap.get(x, y, z);
+
+    public int getBlockLightValue(final int x, final int y, final int z, final int skyLightSubtracted, final EnumColorChannel color) {
+        int value = color == EnumColorChannel.RED ? this.skylightMapR.get(x, y, z)
+            : color == EnumColorChannel.GREEN ? this.skylightMapG.get(x, y, z)
+            : this.skylightMapB.get(x, y, z);
         if (value > 0) {
             Chunk.isLit = true;
         }
         value -= skyLightSubtracted;
-        final int value2 = this.blocklightMap.get(x, y, z);
+        final int value2 = color == EnumColorChannel.RED ? this.skylightMapR.get(x, y, z)
+            : color == EnumColorChannel.GREEN ? this.skylightMapG.get(x, y, z)
+            : this.skylightMapB.get(x, y, z);
         if (value2 > value) {
             value = value2;
@@ -296,5 +368,5 @@
         return value;
     }
-    
+
     public void addEntity(final Entity entity) {
         if (this.isChunkRendered) {
@@ -305,5 +377,5 @@
         final int floor_double2 = MathHelper.floor_double(entity.posZ / 16.0);
         if (floor_double != this.xPosition || floor_double2 != this.zPosition) {
-            System.out.println(new StringBuilder().append("Wrong location! ").append(entity).toString());
+            System.out.println("Wrong location! " + entity);
         }
         int floor_double3 = MathHelper.floor_double(entity.posY / 16.0);
@@ -318,11 +390,11 @@
         entity.chunkCoordY = floor_double3;
         entity.chunkCoordZ = this.zPosition;
-        ((List)this.entities.get(floor_double3)).add(entity);
+        this.entities.get(floor_double3).add(entity);
     }
-    
+
     public void removeEntity(final Entity entity) {
         this.removeEntityAtIndex(entity, entity.chunkCoordY);
     }
-    
+
     public void removeEntityAtIndex(final Entity entity, int index) {
         if (index < 0) {
@@ -332,14 +404,14 @@
             index = this.entities.size() - 1;
         }
-        ((List)this.entities.get(index)).remove(entity);
+        this.entities.get(index).remove(entity);
     }
-    
+
     public boolean canBlockSeeTheSky(final int x, final int y, final int z) {
         return y >= (this.heightMap[z << 4 | x] & 0xFF);
     }
-    
+
     public TileEntity getChunkBlockTileEntity(final int x, final int y, final int z) {
         final ChunkPosition chunkPosition = new ChunkPosition(x, y, z);
-        TileEntity tileEntity = (TileEntity)this.chunkTileEntityMap.get(chunkPosition);
+        TileEntity tileEntity = this.chunkTileEntityMap.get(chunkPosition);
         if (tileEntity == null) {
             final int blockID = this.getBlockID(x, y, z);
@@ -347,14 +419,14 @@
                 return null;
             }
-            ((BlockContainer)Block.BLOCKS_LIST[blockID]).onBlockAdded(this.worldObj, this.xPosition * 16 + x, y, this.zPosition * 16 + z);
-            tileEntity = (TileEntity)this.chunkTileEntityMap.get(chunkPosition);
+            Block.BLOCKS_LIST[blockID].onBlockAdded(this.worldObj, this.xPosition * 16 + x, y, this.zPosition * 16 + z);
+            tileEntity = this.chunkTileEntityMap.get(chunkPosition);
         }
         return tileEntity;
     }
-    
+
     public void addTileEntity(final TileEntity tileEntity) {
         this.setChunkBlockTileEntity(tileEntity.xCoord - this.xPosition * 16, tileEntity.yCoord, tileEntity.zCoord - this.zPosition * 16, tileEntity);
     }
-    
+
     public void setChunkBlockTileEntity(final int x, final int y, final int z, final TileEntity tileEntity) {
         final ChunkPosition chunkPosition = new ChunkPosition(x, y, z);
@@ -375,5 +447,5 @@
         this.chunkTileEntityMap.put(chunkPosition, tileEntity);
     }
-    
+
     public void removeChunkBlockTileEntity(final int x, final int y, final int z) {
         final ChunkPosition chunkPosition = new ChunkPosition(x, y, z);
@@ -382,25 +454,25 @@
         }
     }
-    
+
     public void onChunkLoad() {
         this.isChunkLoaded = true;
         this.worldObj.loadedTileEntityList.addAll(this.chunkTileEntityMap.values());
-        for (int i = 0; i < this.entities.size(); ++i) {
-            this.worldObj.addLoadedEntities(this.entities.get(i));
+        for (List<Entity> entity : this.entities) {
+            this.worldObj.addLoadedEntities(entity);
         }
     }
-    
+
     public void onChunkUnload() {
         this.isChunkLoaded = false;
         this.worldObj.loadedTileEntityList.removeAll(this.chunkTileEntityMap.values());
-        for (int i = 0; i < this.entities.size(); ++i) {
-            this.worldObj.unloadEntities(this.entities.get(i));
+        for (List<Entity> entity : this.entities) {
+            this.worldObj.unloadEntities(entity);
         }
     }
-    
+
     public void setChunkModified() {
         this.isModified = true;
     }
-    
+
     public void getEntitiesWithinAABBForEntity(final Entity entity, final AxisAlignedBB aabb, final List<Entity> list) {
         int floor_double = MathHelper.floor_double((aabb.minY - 2.0) / 16.0);
@@ -413,7 +485,5 @@
         }
         for (int i = floor_double; i <= floor_double2; ++i) {
-            final List<Entity> list2 = (List<Entity>)this.entities.get(i);
-            for (int j = 0; j < list2.size(); ++j) {
-                final Entity entity2 = (Entity)list2.get(j);
+            for (final Entity entity2 : this.entities.get(i)) {
                 if (entity2 != entity && entity2.boundingBox.intersectsWith(aabb)) {
                     list.add(entity2);
@@ -422,5 +492,5 @@
         }
     }
-    
+
     public void getEntitiesOfTypeWithinAABB(final Class<? extends Entity> entityClass, final AxisAlignedBB aabb, final List<Entity> list) {
         int floor_double = MathHelper.floor_double((aabb.minY - 2.0) / 16.0);
@@ -433,7 +503,5 @@
         }
         for (int i = floor_double; i <= floor_double2; ++i) {
-            final List<Entity> list2 = (List<Entity>)this.entities.get(i);
-            for (int j = 0; j < list2.size(); ++j) {
-                final Entity entity = (Entity)list2.get(j);
+            for (final Entity entity : this.entities.get(i)) {
                 if (entityClass.isAssignableFrom(entity.getClass()) && entity.boundingBox.intersectsWith(aabb)) {
                     list.add(entity);
@@ -442,9 +510,9 @@
         }
     }
-    
+
     public boolean needsSaving(final boolean boolean1) {
         return !this.neverSave && ((this.hasEntities && this.worldObj.worldTime != this.lastSaveTime) || this.isModified);
     }
-    
+
     public int setChunkData(final byte[] blocks, final int minX, final int minY, final int minZ, final int maxX, final int maxY, final int maxZ, int size) {
         for (int i = minX; i < maxX; ++i) {
@@ -469,5 +537,7 @@
                 final int n = (i << 11 | j << 7 | minY) >> 1;
                 final int n2 = (maxY - minY) / 2;
-                System.arraycopy(blocks, size, this.blocklightMap.data, n, n2);
+                System.arraycopy(blocks, size, this.blocklightMapR.data, n, n2);
+                System.arraycopy(blocks, size, this.blocklightMapG.data, n, n2);
+                System.arraycopy(blocks, size, this.blocklightMapB.data, n, n2);
                 size += n2;
             }
@@ -477,5 +547,7 @@
                 final int n = (i << 11 | j << 7 | minY) >> 1;
                 final int n2 = (maxY - minY) / 2;
-                System.arraycopy(blocks, size, this.skylightMap.data, n, n2);
+                System.arraycopy(blocks, size, this.skylightMapR.data, n, n2);
+                System.arraycopy(blocks, size, this.skylightMapG.data, n, n2);
+                System.arraycopy(blocks, size, this.skylightMapB.data, n, n2);
                 size += n2;
             }
@@ -483,5 +555,5 @@
         return size;
     }
-    
+
     public Random getRandomWithSeed(final long seed) {
         return new Random(this.worldObj.randomSeed + this.xPosition * this.xPosition * 4987142 + this.xPosition * 5947611 + this.zPosition * this.zPosition * 4392871L + this.zPosition * 389711 ^ seed);
